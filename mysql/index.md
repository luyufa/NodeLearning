##### mysql InnoDB引擎下的索引
> 索引本身也不小，不可能直接放到内存中，也行要存储到磁盘，因此查询索引的过程便涉及磁盘IO

磁盘是由一组大小相同的同轴圆组成，磁盘可以转动的，磁头获取数据。简单说就是先`寻道`(选择一个盘面)后`旋转`(磁头读写数据),磁盘IO相对主存慢，于是为了提高效率，每次读取数据都会先`预读`(即使只需要一个字节，磁盘也会从这个位置开始，顺序向后读取一定长度的数据放入内存)。


在数据库系统的B+Tree中，每一个结点大小等于一页(16k),这样一次IO便读取了整个结点数据

在InnoDB引擎下数据按照索引组织表，通过主键构造一颗B+Tree，并且在叶子结点存放整张表的行记录(这种索引叫聚集索引),因此表中必须要有主键，按照如下规则选取
1. 显示指定primary key
2. 第一个指定为非空的唯一索引
3. 隐式生成一个rowid

非聚集索引（辅助索引）：叶结点不包含全部数据，叶结点中仅包含键值和书签（指向对应数据行），因为Innodb是索引组织表，所以这里的书签即相应行的聚集索引键（主键）


按照一定顺序引用多个列，叫做联合索引

聚集索引逻辑连续，索引页按照主键顺序排列，叶子页通过双向链表连接，主键的排序查找和范围查找特别快

InnoDB引擎下的mysql，无法指定哈希索引，是由引擎自己控制的，且哈希索引只能进行等值查询

##### 索引优化
> people <id name card>这是一个联合索引

基数大，重复率低，查询次数高于更新次数 的键合适建立索引

1. 全列匹配(`<id,name,card>`)

```
select * from people where id=xxx and name=xxx and card=xxx
```

2. 最左匹配(`<id>`)

```
select * from people where id=xxx
```

3. 询条件用到了索引中列的精确匹配，但是中间某个条件未提供。(`<id>`)

```
select * from people where id=xxx and card=xxx
```

4. 查询条件没有指定索引第一列(无法使用索引)

```
select * from people where card=xxx
```

5.匹配某列的前缀字符串(`<id>`,只要通配不在最开始则可以用到索引)

```
select * from people where id=xxx and name like %xxx%
```


##### 常见索引问题


1. 为什么不选取过长的键为主键？

 * 每一个辅助索引都会引用主键，导致辅助索引占用过大占用空间大

2. 为什么每个表仅能有一个主键？

  * 索引组织表，由于实际数据页只能按照一颗B+Tree排序，所以每张表只能有一个聚集索引

3. 为什么使用自增主键？

 * 按照InnoDB索引组织表的方式，使用自增主键，每次插入新记录会顺序插入到当前索引结点的后续位置，当一页写满自动开辟下一页（顺序填满）；但是如果不使用自增主键，每次插入值近似随机，每次新记录都要插入到现有页的中间，会增加很多不必要的分页、拆页、移动操作

6. InnoDB常用的索引类型？

 * 普通索引index
 * 唯一索引unique index
 * 主键：是指定了primary key的唯一索引

7. InnoDB索引数据结构？

 * B+Tree
 * 自适应哈希