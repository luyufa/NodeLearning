
## redis缓存击穿、雪崩、并发

##### 缓存设计

* 粒度

缓存对象中究竟要放那些数据？一种数据一个对象，简单，读取写入速度都快，但是种类一多便不好管理；多种数据糅合到一个对象里，方便使用，但是会造成资源浪费。最好根据合适的业务场景拆分不同的缓存粒度。


* 结构

redis有五种可用的数据结构，`string` `list` `hash` `set` `zset`，根据不同的业务使用不同的数据结构


* 更新

  * 被动失效:一般在设置缓存时都设置上过期时间，到期自动删除
  * 主动失效:在更新数据时，更新或删除(懒加载,会出现空窗期)缓存


很多场景下使用redis来降低db压力，可以有效提升并发，比较通用的一个套路是
先查询reids缓存是否存在，存在直接返回，不存在则查询数据库，并为该次查询结果设置缓存及缓存时间，随后返回结果

```
const cache=redis.get(key)
if(cache){
    return cache
}
const dbData=db.select()
redis.set(key,dbData,maxAge)
return dbData

```

需要注意的是缓存的删除应该放在数据库更新之后，如先删除缓存在更新数据库，试想同时并发get和put操作，此时put先删除缓存，get无法命中，查询数据库(依旧是老数据)，缓存更新，put操作在更新完数据库....就造成了一直都有脏数据;



##### 缓存穿透

问题：一般查询数据库是开销包括不限于内存、cpu、时间等都是要高于redis的，而缓存穿透一般是**客户端恶意**行为，故意查询不存在的东西，造成大量请求压到数据库。

解决：既然是客户端行为问题，那么便从客户端与服务端交互上严加防范，合理校验查询参数，比如明显错误的key直接无需查询；另一方面是直接使无效查询无法第二次进入数据库，每发生一次穿透时，便设置一个特殊值。

```
const cache=redis.get(key)
if(cache){
    return cache
}
const dbData=db.select()
if(!dbData){
    redis.set(key,特殊值,maxAge)
}
else{
    redis.set(key,dbData,maxAge)
}
return dbData;
```

##### 缓存雪崩

问题：其实缓存雪崩来自于一个看似合理实则也合理的设计，**缓存失效时间**，想想这样一个场景，一大批缓存都在某一个时间点同时失效了，就会导致短时间内大量请求进入数据库，

解决：解决思路也和简单既然同时失效导致高峰，那么错开失效不就好了么？我们只需要在为缓存设置过期时间时，在不影响业务的前提下，对原时间加减一个随机时间即可。


##### 缓存并发

问题：很上面类似，在某一个时间点缓存失效了，但巧好此该请求刷的一下进来300个，然后基本同时判断缓存不存在，全跑数据库去了....

解决：有两种比较好的方法

1. 其一为“永不过期”，既然是因为缓存失效导致的并发查询数据库，那么只要缓存永远不失效不就好了，但我们在业务中基本没有那么一劳永逸的好事，始终需要去修改，我们可以开启一个定时任务去定时更新缓存或者一直检测其是否快过期，由我们主动更新缓存。
2. 其二为“分布式锁”，想想下，300个请求同时到达，但是只有一个去查询数据库，其余299个都在等待其查询结果，待查询毕则告知这299个用户，让他们直接使用这个结果就ok。


