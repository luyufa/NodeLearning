
## redis缓存击穿、雪崩、并发

##### 缓存设计

* 粒度

缓存对象中究竟要放那些数据？一种数据一个对象，简单，读取写入速度都快，但是种类一多便不好管理；多种数据糅合到一个对象里，方便使用，但是会造成资源浪费。最好根据合适的业务场景拆分不同的缓存粒度。


* 结构

redis有五种可用的数据结构，`string` `list` `hash` `set` `zset`，根据不同的业务使用不同的数据结构


* 更新

  * 被动失效:一般在设置缓存时都设置上过期时间，到期自动删除
  * 主动失效:在更新数据时，更新或删除(懒加载,会出现空窗期)缓存


很多场景下使用redis来降低db压力，可以有效提升并发，比较通用的一个套路是
先查询reids缓存是否存在，存在直接返回，不存在则查询数据库，并为该次查询结果设置缓存及缓存时间，随后返回结果

```
const cache=redis.get(key)
if(cache){
    return cache
}
const dbData=db.select()
redis.set(key,dbData,maxAge)
return dbData

```

需要注意的是缓存的删除应该放在数据库更新之后，如先删除缓存在更新数据库，试想同时并发get和put操作，此时put先删除缓存，get无法命中，查询数据库(依旧是老数据)，缓存更新，put操作在更新完数据库....就造成了一直都有脏数据;



##### 缓存穿透

问题：一般查询数据库是开销包括不限于内存、cpu、时间等都是要高于redis的，而缓存穿透一般是**客户端恶意**行为，故意查询不存在的东西，造成大量请求压到数据库。

解决：既然是客户端行为问题，那么便从客户端与服务端交互上严加防范，合理校验查询参数，比如明显错误的key直接无需查询；另一方面是直接使无效查询无法第二次进入数据库，每发生一次穿透时，便设置一个特殊值。

```
const cache=redis.get(key)
if(cache){
    return cache
}
const dbData=db.select()
if(!dbData){
    redis.set(key,特殊值,maxAge)
}
else{
    redis.set(key,dbData,maxAge)
}
return dbData;
```

##### 缓存雪崩

问题：其实缓存雪崩来自于一个看似合理实则也合理的设计，**缓存失效时间**，想想这样一个场景，一大批缓存都在某一个时间点同时失效了，就会导致短时间内大量请求进入数据库，

解决：解决思路也和简单既然同时失效导致高峰，那么错开失效不就好了么？我们只需要在为缓存设置过期时间时，在不影响业务的前提下，对原时间加减一个随机时间即可。


##### 缓存并发

问题：很上面类似，在某一个时间点缓存失效了，但巧好此该请求刷的一下进来300个，然后基本同时判断缓存不存在，全跑数据库去了....

解决：有两种比较好的方法

1. 其一为“永不过期”，既然是因为缓存失效导致的并发查询数据库，那么只要缓存永远不失效不就好了，但我们在业务中基本没有那么一劳永逸的好事，始终需要去修改，我们可以开启一个定时任务去定时更新缓存或者一直检测其是否快过期，由我们主动更新缓存。
2. 其二为“分布式锁”，想想下，300个请求同时到达，但是只有一个去查询数据库，其余299个都在等待其查询结果，待查询毕则告知这299个用户，让他们直接使用这个结果就ok。

###### reids分布式锁实现

1. 获取锁

`set resource_key rand_value nx px 30000`

* `rand_value`是由客户端生成的一个随机字符串，它要保证在足够长的一段时间内在所有客户端的所有获取锁的请求中都是唯一的。


* `NX`表示只有当`resource_key`对应的key值不存在的时候才能`SET`成功。这保证了只有第一个请求的客户端才能获得锁，而其它客户端在锁被释放之前都无法获得锁。

* PX 30000表示这个锁有一个30秒的自动过期时间。这个锁必须要设置一个过期时间。否则的话，当一个客户端获取锁成功之后，假如它崩溃了导致它再也无法和Redis节点通信了，那么它就会一直持有这个锁，而其它客户端永远无法获得锁了。获得锁的客户端必须在这个时间之内完成对共享资源的访问。


2. 释放锁

```
if(redis.get('resource_key')===rand_value){
    redis.del('resource_key')
}
```


为什么设置一个随机字符串rand_value？
因为它保证了一个客户端释放的锁必须是自己持有的那个锁。假如获取锁时SET的不是一个随机字符串，而是一个固定值，那么可能会发生下面的执行序列：

1. A获取锁成功。
2. A在某个操作上阻塞了很长时间。
3. 过期时间到了，锁自动释放了。
4. B获取到了对应同一个资源的锁。
5. A从阻塞中恢复过来，释放掉了B持有的锁。
6. 之后，B在访问共享资源的时候，就没有锁为它提供保护了





