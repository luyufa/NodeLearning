## redis设计实现-字典
> 字典一种key-value数据结构,key是唯一的，redis中的增、删、改、查便是建立于此


字典底层使用哈希表实现，哈希表有多个哈希结点构成

###### 哈希结点
```
struct dictEntry{
    void key 键
    void value 值
    dictEntry *next 指向下个哈希结点(链地址法解决冲突,将多个哈希值相同的哈希结点链接在一起)
}
```

###### 哈希表
```
struct dictht{
    dictEntry [] 哈希结点数组
    int size 哈希表大小
    int used 哈希表已有结点数量
    int sizemask 哈希表大小掩码，计算索引值总是等于size-1，
    sizemask和哈希值决定了一个键应该放到数组那个索引上
}
```

###### 字典
```
struct dict{
    dictht ht[2] 一般情况下仅使用ht[0]哈希表，ht[1]仅在ht[0] rehash时使用
    rehashindex 记录rehash进度，如果没有在rehash则为-1
}

```


###### 哈希算法

* 当要将一个键值对放入字典时，要先根据键值对的键计算出hash值和索引值，然后在把对应的hash结点放入hash表示数组指定位置。
* 当不同的键分配到同一个索引上时，称为hash冲突，redis采用链地址法解决冲突，每一个哈希结点都有一个next指针，被分配到同一个索引的hash结点，通过next指针链接起来。因为hash结点组成的链表不存在尾指针，所以总是添加到链表头，算法复杂度为O(1)。
* 当获取一个冲突hash结点时，只能先通过索引找到有冲突hsah结点链接而成的链表，依次遍历比较，算法复杂度为 O(1)+O(n)
* hash负载因子,创建hash表示时默认有1个负载因子，是空间和时间的折中方案，当负载因子增大会降低hash表大小，这样冲突概率增大，增加查询时开销；当负载因子减小会增大hash表大小，这样会提高查询效率。

###### reshah
为了将负载因子维持在一个合适的范围内，当hash表保存的键值对数量太多或太少时需要进行扩展或收缩，redis采用reshah进行,rehash往往不是一次性，集中性的进行，而是渐进时、分多次完成。


当负载因子小于0.1时开始收缩操作，当负载因子大于1且位执行save操作或负载因子大于5且正在执行save操作是开始扩展操作


`负载因子=ht[0].used/ht[0].size`

步骤如下:

 1. 为字典th[1]分配空间，分配的空间大小取决于th[0].used和操作
    * 扩展操作，th[1]大小为第一个大于等于`ht[0].used*2`的2^n，例如ht[0].used=7 那么ht[1]应该分配的大小为`16` (2^4 > 7*2,16是第一个大于14的数)
    * 收缩操作，th[1]大小为第一个大于等于`ht[0].used`的2^n，例如ht[0].used=7 那么ht[1]应该分配的大小为`8` (2^3 > 7,8是第一个大于7的数)
 2. 将th[0]中的所有键值对重新计算hash值和索引值到th[1]中
 3. 当th[0]为空表时，将th[1]设置为th[0],在th[1]设置一个空表，为下次rehash准备



