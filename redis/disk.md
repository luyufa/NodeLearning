## 持久化

##### rdb
> 在指定时间间隔内发生指定次数次写入，则会生成一个快照,即将内存中的数据写入磁盘，生成一个`.rdb`文件,在重启服务时恢复数据。


###### 如何生成快照?

  1. redis会fork一个子进程
  2. 主进程负责接收客户端请求并处理，子进程将内存数据写入硬盘临时文件
  3. 将临时文件`rename(原子性)`为`.rdb`文件
  4. 新的`.rdb`覆盖老的`.rdb`

###### 主要配置
save <指定时间间隔> <执行指定次数更新操作>
  ```
 save 900 1
 save 300 10
 save 60 10000
  ```

文件名、目录、数据压缩
```
dbfilename dump.rdb
dir ./
rdbcompression yes
```

###### 触发生成快照

 * `save` 手动调用,阻塞其他操作
 * `bgsave` 手动调用,异步生成
 * `flushall` 清空数据库数据，该命令会生成快照
 * `shutdown` 关闭数据库,该命令会生成快照



###### 恢复数据

重启redis服务器即可恢复


######  优缺点

* 合适数据一致性要求不高的场景(`rdb`容易在上一次生成快照后宕机就会缺少数据)
* 性能比`aof`持久化要高
* 每次保存`rdb`文件时都需要`fork`子进程来处理，在数据较大时比较耗时
* 数据恢复速度较`aof`快(一是RDB文件中每一条数据只有一条记录，不会像AOF日志那样可能有一条数据的多次操作记录。所以每条数据只需要写一次就行了,另一个原因是RDB文件的存储格式和Redis数据在内存中的编码格式是一致的，不需要再进行数据编码工作。在CPU消耗上要远小于AOF日志的加载)





##### aof
> 以指定写入模式，在特定模式下将写操作记录在`.aof`文件,在重启服务时恢复数据

###### 主要配置

开启aof，默认是no

```
appendonly yes
```

写aof文件模式

```
appendfsync always:接受到写操作命令，就写入aof，效率最低，但数据完整性最高
appendfsync everysec:每秒写入aof一次
appendfsync no:把数据交由os cache，由os找时间写入aof
```

###### 重写

aof持久化中很多数据是会过期、被用户删除、或者被缓存清除算法清理掉。redis内存中会不断淘汰数据，但是这些淘汰的数据可能有对应的aof记录存在，这样aof文件便会无限增大。

所以aof会在后台一段时间按照重写策略进行一次重写操作

```
auto-aof-rewrite-percentage 100（上一次重写大小）

auto-aof-rewrite-min-size 64mb
```

如上次重写完aof大小为100mb，那此次接着100mb开始写入，当增长比例超过100%，也就是200mb，同时大于最小重写阀值64mb，则重写aof文件。

1. `redis` `fork`一个子进程
2. 子进程基于当前内存中的数据，构建临时`aof`文件
3. 主进程接受写操作，并且依旧记录到老的`aof`文件中，同时还会记录到缓冲区
4. 当子进程重写操作完成后，将缓冲区中的所有数据一次性写入临时`aof`文件
5. 新的`aof`文件覆盖老的`aof`文件




###### 恢复数据

重启redis服务器即可恢复


######  优缺点

* 合适数据一致性要求较高场景



 参考

* [解密Redis持久化](http://blog.nosqlfan.com/html/3813.html)
* [Redis 持久化之RDB和AOF](https://segmentfault.com/a/1190000012185846)