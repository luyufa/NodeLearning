## redis设计实现-数据结构-SDS

> redis 中键值对在底层都是由SDS(简单动态字符串)实现的


###### SDS 结构
 redis由c语言实现，但是未直接使用c语言提供的字符串，而是定义了如下结构
```
struct {
   char buf[], 字节数组，保存字符串

   int len, 记录buf中已使用长度，等于SDS长度

   int free, 记录buf中未使用长度
}
```

  1. 获取字符串长度

   * 传统C字符串本身不记录长度，因此必须遍历每一个字符，直到空字符('\0' C语言以此为结尾)为止,算法复杂度为`O(N)`
   * SDS字符串本身记录了`len` 因此获取字符串长度算法复杂度为`O(1)`
   ```
   strlen key 不会成瓶颈，O(1)
   ```

  2. 杜绝缓冲区溢出

   * 传统C字符串，因为不记录长度，因此在增加字符串长度时，如果未申请到足够的空间，便会造成溢出
   * SDS字符串在每次修改时，都会检测空间大小是否满足修改需求，始终会调整到合适的大小。

  3. 优化内存重分配-空间预分配

   在对SDS进行长度增加的操作时,如果修改后的长度小于1MB，则分配同样大小的未使用空间。例如某次修改之后的SDS `len=13` 那么此时`free=13` `buf=13+13+1(保存空字符)`；如果修改之后的长度大于1MB则，分配1MB的未使用空间。

  4. 优化内存重分配-惰性释放

   在对SDS进行缩短操作时，并不使用内存重分配来回收多余空间，而是使用`free`记录下来，将来使用。(SDS提空api来释放内存，不要担心会造成内存泄漏)

  5. 二进制安全

   * 传统C字符串以'\0'作为结束，因此不能保存音频、视频等二进制数据
   * SDS的buf是用来保存一系列二进制数据，写入时是什么样，读出来便是什么样(以len来判断字符串是否结束)

  6. 重用C字符串函数

   SDS 中的buf依旧保持了在末尾放入'\0'，以此使保存文本数据的SDS重用一部分C字符串函数。


