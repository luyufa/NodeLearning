## 单机数据库

```
struct RedsiServer{
    int dbmun, 数据库数量,该属性由配置文件中database决定
    redisDb [] 数据库数组
}
```

```
struct RedisClient{
    redisDb *db 指向当前使用的数据库
}
```

在服务器多数据库使用的情况下,最好在执行命令时先执行`select`命令选择数据库




###### 键空间
>`redis` 是一个`key-value`数据库，数据库中所有键值对都保存在redisDb的dict字典中，这个字典就称为键空间

```
struct redisDd{
    dict *dict
}
```
键空间和用户所见的是直接对应的，键空间中键便是数据库键，键空间中值便是任意Redis对象，对数据库的增删改查操作都是对键空间字典进行操作实现的。

* 读写键空间时的维护操作

  1. 读取一个键(取或写都要对键进行读取),更新键空间中的`hit`、和`miss`次数。`info stats`命令的`keyspace_hits`和`keyspace_miss`可以查看。
  2. 读取一个键时需要更新该键的LRU(最近使用时间),改值用于计算键的空转时间,使用`object idletime key`查看
  3. 读取一个键时，需要在过期字典里查看其是否过期，如过期则删除，否则返回。


###### 过期

* `expire key seconds`
* `pexpire key milliseconds`
* `expireat key timestamp`
* `pexpireat key millisecond-timestamp`
* `ttl`
* `pttl`
* `persist`

`expire`、`pexpire`、`expireat`最终都是转换为`pexpireat`执行


```
struct redisDb{
    dict *expire
}
```
redisDb中存在一个过期字典，过期字典键是一个指向键空间中的某个键(键空间键和过期字典键都指向同一对象，节约内存)，过期字典值是一个整数值，保存了键的过期时间(毫秒级时间戳)


* 过期判定
  1. 是否在过期字典中，如果在取得过期时间
  2. 当前unix时间戳是否大于过期时间，如是则过期，否则未过期


* 过期删除策略(redis采用惰性删除和定期删除配合)
  *  定时删除，设置过期时间时，创建一个定时器timer,当过期时立即删除。该方法对内存友好，过期键立即删除不会占用内存空间，但是对cpu不友好，当删除的过期键较多时比较占用cpu，影响响应时间和吞吐量
  *  惰性删除，放任过期键不管，每次读取键时都在过期字典里查询一边，如果过期删除，否则返回。该方法对cpu友好，不会过度占用cpu资源，但是度内存不友好，例如有些键已经过期，但是一直没有被读取，也就无法删除释放内存了，这大约可以看做内存泄漏了，大量垃圾数据无法释放。
  *  定期删除，每隔一段时间，检测一次数据库中的过期键且删除。这是一种内存和cpu的折中方案。每次随机从数据库中随机取一定量键，删除过期的。

* 过期对持久化的影响

  * 在save或bgsave生成rdb文件时，过期键是不会写入rdb文件的。
  * 服务器以主服务器模式运行时，在载入rdb文件时，过期键会被忽略，不会载入。
  * 服务器主服务器模式运行时，在载入rdb文件时，无论是否过期都会被载入
  * 当键过期但是还未被删除时不会对aof造成影响，只有等键被删除了，才会在aof文件中追加del命令



