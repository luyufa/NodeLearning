## redis设计实现-跳跃表
> 跳跃表，一种有序数据结构，在每个结点维持多个指向其他结点的指针，支持平均O(logN)、最坏O(n)的查询

```
struct skipListNode{
    int sorce 分值，用于排序

    object value 结点值

    skipListNode *backward 后退指针，指向前一个结点

    skipListLevel {
        skipListNode *forward 前进指针

        int span 跨度
    }level []  通过层来加快访问结点的速度
}
```

```
struct skipList{
    int len 结点数量

    int leve 最大层数

    skipListNode *head 跳跃表头结点

    skipListNode *tail 跳跃表尾结点
}
```

###### 跳跃表搜索A

1. 从顶层开始通过forward指针和span找到下一个结点X
2. 比较A与X的大小关系，如果A大于X，且下个结点不是尾结点，则继续在该层前进，至到A小于X或下个结点是尾结点。通过X结点进入下层
3. 如果A小于X，则通过backward后退比较

![事件循环](https://github.com/luyufa/NodeLearning/blob/master/redis/img/skipList.png)

例如查找元素117

1. 比较21，比21大，前进
2. 比较37，比37大，下个结点是尾结点，进入下层
3. 比较71，比71大，下个结点是尾结点，进入下层
4. 比较85，比85大，前进
5. 比较117，等于117 找到


例如查找元素14

1. 比较21，比21小，后退
2. 比较14，等于14，找到

###### 跳跃表插入结点

当大量的结点插入原链表后，上层链表便不够用了，此时采用随机法，对新插入的结点“抛硬币”,结果正就向上层提拔，如果负就停止。(建立前驱后继)

###### 跳跃表删除结点

跳跃表删除结点很简单，自上而下每一层都删除该结点(建立前驱后继)


###### 跳跃表特性
 * 很多层组成
 * 每层都是一个有序链表，至少包含两个结点min和max
 * 最底层链表包含所有元素
 * 如果某结点在某一层出现，则该层之下所有层都会出现
 * 每个结点都包含两个指针，一个指向同层下一个结点，一个指向下层同一个结点

