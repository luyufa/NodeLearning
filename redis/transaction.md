## 事务transaction

>Redis中的事务是一组命令的集合，是Redis中的最小执行单元，要么全部执行，要么全部未执行,Redis中的命令也是最小执行单元，具备原子特效(防止资源竞争)


#### 使用方式
1. 使用`MULTI`命令，此后所有命令不会立即执行，都进入执行队列
2. 使用`EXEC`命令，按照发送顺序依此执行执行队列中的命令， 返回每个命令的结果

如果在发送EXEC命令前客户端掉线了则清空执行队列，如果在发送EXEC命令后客户端掉线了则，无关系，依旧执行

事务还保证了在执行过程中不会被其他命令插入

```
127.0.0.1:6379> multi
OK
127.0.0.1:6379> set a a
QUEUED
127.0.0.1:6379> set b b
QUEUED
127.0.0.1:6379> exec
1) OK
2) OK
```

#### 错误处理

1. 命令本身错误，只要执行队列中存在错误命令，则直接抛出错误，连正确的也不会执行
2. 运行错误（命令与数据类型不匹配），当某一条运行出错的时候，其他命令依旧正常执行

Redis不提供回滚功能，也使得Redis简洁快速。

#### watch

使用`WATCH`命令监控一个key，若果key被修改，则阻止一个事务的执行。

在事务中无法使用前一条命令的输出作为后一条的输入，例如在实现`incr`命令时，无法使用GET命令的结果作为SET命令的参数。为此换个思路，GET命令后保证该值不被其他客户端修改，直到函数执行完成。

```
funtion incr(){
   WATCH key;
   MULTI
   const value = (GET key || 0)+1;
   SET key value
   EXEC
}
```
如果在执行过程中其他客户端修改了key值则incr函数中事务不会执行，所以可以在incr函数执行失败后重新执行整个函数。

`EXEC`会取消所有键的监控，也可以是使用`UNWATCH key`


